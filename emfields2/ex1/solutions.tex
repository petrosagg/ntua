\section{Άσκηση 1}

Αρχικά ορίζουμε τρεις περιοχές του χώρου:

\[ 1: 0 \leq r \leq a \]
\[ 2: a \leq r \leq b \]
\[ 3: b \leq r \]




% \section{Άσκηση 2}
% 
% Για να βρούμε τον χάρτη θα κάνουμε δυαδική αναζήτηση στους διακόπτες για κάθε
% πόρτα. Δεδομένου ότι ξέρουμε τη σωστή θέση των διακοπτών όλων των πορτών μέχρι
% την πόρτα $i$, μπορούμε να βρούμε τον διακόπτη της πόρτας $i + 1$ αλλάζοντας
% τους μισούς διακόπτες που δεν έχουμε αντιστοιχίσει ακόμα και βλέποντας αν η
% πόρτα $i + 1$ άλλαξε κατάσταση. Για την πρώτη πόρτα δεν χρειάζεται να έχουμε
% κανέναν διακόπτη στη σωστή θέση οπότε μπορούμε να κάνουμε τη δυαδική αναζήτηση
% κατευθείαν. Αυτή είναι και η βάση της αναδρομής.
% 
% Εφόσον για κάθε διακόπτη χρειάζεται να κάνουμε δυαδική αναζήτηση σε $n$
% στοιχεία θα χρειαστούμε $\log{}n$ δοκιμές, και επειδή έχουμε αυτό θα το κάνουμε
% για $n$ πόρτες θα χρειαστούν συνολικά $O(n\log{}n)$ δοκιμές.
% 
% \subsubsection{Αναλυτική περιγραφή}
% 
% Για να περιγράψουμε τον αλγόριθμο ανακατασκευής και να μετρήσουμε τον αριθμό
% δοκιμών που κάνει θα ορίσουμε μία συνάρτηση $DoorsOpen$ η οποία δέχεται ως
% παράμετρο ένα σύνολο όπου για κάθε διακόπτη $i$ περιέχει είτε $(i, \true)$ αν ο
% διακόπτης είναι στη θέση ON είτε $(i, \false)$ αν ο διακόπτης είναι στη θέση
% OFF. Η συνάρτηση επιστρέφει το πλήθος των πορτών που είναι ανοιχτές ξεκινώντας
% από την αρχή του διαδρόμου.
% 
% Θα ορίσουμε τον αλγόριθμο υπολογισμού ορίζοντας τρεις συναρτήσεις. Η συνάρτηση
% $Map(i)$ η οποία υπολογίζει για κάθε πόρτα $j \leq i$  τον διακόπτη που της
% αντιστοιχεί και το state του διακόπτη αυτού που ανοίγει την πόρτα.
% 
% \begin{algorithm}[H]
%   \caption{\label{alg:ex2-findswitch}Ανακατασκευή Χάρτη}
%     \begin{algorithmic}[1]
%       \Function{\textsf{Map}}{$i$}
%         \If{$i = 0$}
%           \State\Return{$\emptyset$}
%         \Else
%           \State\Return{$M(i-1) \cup \{(i, Find(i, 1, n+1))\}$}
%         \EndIf
%       \EndFunction
%     \end{algorithmic}
% \end{algorithm}
% 
% Η συνάρτηση $FindSwitch(i, l, h)$ η οποία κάνει δυαδική αναζήτηση στους
% διακόπτες $[l, h)$ για να βρει τον διακόπτη της πόρτας $i$ και αφού τον βρει
% επιστρέφει τον διακόπτη και το state που ανοίγει την πόρτα.
% 
% \begin{algorithm}[H]
%   \caption{\label{alg:ex2-findswitch}Εύρεση διακόπτη πόρτας}
%     \begin{algorithmic}[1]
%       \Function{\textsf{Find}}{$i$, $l$, $h$}
%         \If{$h - l = 1$}
%           \State\Return{$(l, Check(i, l, h))$}\Comment{Switch found}
%         \Else
%           \If{$Check(i, l, h) = Check(i, l, l+\frac{h}{2})$}
%             \State\Return{$Find(i, l, l+\frac{h}{2})$}
%           \Else
%             \State\Return{$Find(i, l+\frac{h}{2}, h)$}
%           \EndIf
%         \EndIf
%       \EndFunction
%     \end{algorithmic}
% \end{algorithm}
% 
% Η συνάρτηση $Check(i, l, h)$ ανάβει τους διακόπτες $s \in [l, h)$, κλείνει τους
% διακόπτες $s \notin [l, h)$, βάζει όλους τους διακόπτες που αντιστοιχούν σε
% πόρτα $d < i$ στη σωστή θέση, και επιστρέφει αν η πόρτα $i$ είναι ανοιχτή σε
% αυτή τη δοκιμή. Επειδή αυτή η συνάρτηση φροντίζει οι προηγούμενοι διακόπτες να
% είναι στη σωστή θέση μπορεί πάντα να παρατηρήσει την κατάσταση της πόρτας $i$.
% 
% \begin{algorithm}[H]
%   \caption{\label{alg:ex2-findswitch}Έλεγχος πόρτας}
%     \begin{algorithmic}[1]
%       \Function{\textsf{Check}}{$i$, $l$, $h$}
%         \State{$TestSwitches \gets \{(s, s \in [l, h)]): s \notin M(i-1)\}$}
%         \State\Return{$DoorsOpen(TestSwitches \cup M(i -1)) \geq i$}
%       \EndFunction
%     \end{algorithmic}
% \end{algorithm}
% 
% \section{Άσκηση 3}
% 
% Ο αλγόριθμος για την εύρεση του θησαυρού θα κάνει μία σειρά βημάτων $i$ όπου σε
% κάθε βήμα θα διανύει απόσταση $2^{i}$ προς είτε τη θετική είτε την αρνητική
% κατεύθυνση και αν δεν βρει τον θησαυρό θα επιστρέφει στη θέση $0$. Σε κάθε μόνο
% βήμα θα επιλέγει κατεύθυνση προς τα θετικά και σε κάθε ζυγό βήμα προς τα
% αρνητικά.
% 
% Εφόσον ο θησαυρός απέχει $|x|$ από το μηδέν, θεωρούμε $j = \lfloor
% log_{2}(|x|) \rfloor$ το μέγιστο βήμα του αλγορίθμου στο οπόιο διανύεται
% απόσταση $< |x|$. Άρα ο αλγόριθμος θα εκτελέσει σίγουρα $j$ βήματα
% χωρίς να βρει τον θησαυρό. Αν είμαστε τυχεροί τότε στο αμέσως επόμενο βήμα θα
% βρεθεί ο θησαυρός διανύοντας επιπλέον απόσταση $|x|$. Αν είμαστε άτυχοι τότε το
% αμέσως επόμενο βήμα θα είναι προς την αντίθετη κατεύθυνση και ο θησαυρός θα
% βρεθεί με συνολική επίπλέον απόσταση $2 \cdot 2^{j + 1} + |x|$.
% 
% Άρα στη χειρότερη περίπτωση Θα διανύσει απόσταση
% 
% \begin{equation} \label{eq1}
% \begin{split}
%   D & = \sum_{i = 1}^{j}2 \cdot 2^{i} + 2 \cdot 2^{j + 1}  + |x|  \\
%     & = 2 (2^{j + 2} - 1) + |x|
% \end{split}
% \end{equation}
% 
% Όμως από τον ορισμό του $j$ ισχύει ότι
% 
% \begin{equation} \label{eq1}
% \begin{split}
%   2^{j} & = 2^{\lfloor log_{2}(|x|) \rfloor} \\
%         & \leq 2^{log_{2}(|x|)} \\
%         & \leq |x|
% \end{split}
% \end{equation}
% 
% Άρα για τη συνολική απόσταση έχουμε
% 
% \begin{equation} \label{eq1}
% \begin{split}
%   D & = 2 (2^{j + 2} - 1) + |x| \\
%     & = 2 (4 \cdot 2^{j} - 1) + |x| \\
%     & \leq 2 (4 |x| - 1) + |x| \\
%     & \leq 9 |x|
% \end{split}
% \end{equation}
% 
% \section{Άσκηση 4}
% 
% \subsection{Αντιπαραδείγματα άπληστων αλγορίθμων}
% 
% \subsubsection{Άπληστος με επιλογή μέγιστου μήκους}
% 
% Με είσοδο τα διαστήματα $\{[0, 2), [1, 4), [3, 5)\}$ ένας τέτοιος αλγόριθμος θα
% επέλεγε αρχικά το διάστημα $[1, 4)$ και μετά δεν θα είχε κάποια άλλη επιλογή,
% άρα θα υπολόγιζε μέγιστο μήκος $3$. Όμως η επιλογή $\{[0, 2), [3, 5)\}$ έχει
% μήκος $4$ και άρα ο αλγόριθμος δεν βρίσκει το βέλτιστο.
% 
% \subsubsection{Άπληστος με επιλογή ελάχιστου χρόνου ολοκλήρωσης}
% 
% Με είσοδο τα διαστήματα $\{[0, 1), [0, 2)\}$ ένας τέτοιος αλγόριθμος θα επέλεγε
% αρχικά το διάστημα $[0, 1)$ και μετά δεν θα είχε κάποια άλλη επιλογή, άρα θα
% υπολόγιζε μέγιστο μήκος $1$. Όμως η επιλογή $\{[0, 2)\}$ έχει μήκος $2$ και άρα
% ο αλγόριθμος δεν βρίσκει το βέλτιστο.
% 
% \subsection{Αποδοτικός αλγόριθμος}
% 
% \subsubsection{Κατασκευή}
% 
% Θα θεωρήσουμε ότι $\forall i, j: i < j \implies f_{i} \leq f_{j}$. Αυτό
% μπορούμε εύκολα να το πετύχουμε ταξινομώντας την είσοδο. Επίσης ορίζουμε τη
% σχέση $p(i) = \max \{ j: j < i \land f_{j} \leq s_{i} \}$ η οποία δεδομένου
% ενός $i$ υπολογίζει το μέγιστο διάστημα $j$ που τελειώνει πριν την έναρξη του
% $i$. Με βάση αυτά ορίζουμε την αναδρομική σχέση
% 
% \[ OPT(i) = \left\{
%               \begin{array}{lr}
%                   f_{i} - s_{i}                           & \text{if } i = 1 \\
%                   max \left\{
%                     \begin{array}{lr}
%                       f_{i} - s_{i} + OPT(p(i)) \\
%                       OPT(i - 1) \\
%                     \end{array}
%                   \right\}                                & \text{if } i > 1
%               \end{array}
%             \right.
% \]
% 
% Η συνάρτηση $OPT(i)$ υπολογίζει το μέγιστο μήκος μη επικαλυπτόμενων διαστημάτων
% λαμβάνοντας υπόψιν όλα τα διαστήματα $j: j \leq i$. Η λύση του προβλήματος
% δίνεται από το $OPT(n)$.
% 
% \subsubsection{Επιχείρημα ορθότητας}
% 
% Σε κάθε βήμα ο αλγόριθμος έχει δύο επιλογές. Είτε να επιλέξει το $i$-οστό
% διάστημα είτε να μη το επιλέξει.
% 
% Στην περίπτωση που επιλέξει το $i$-οστό διάστημα το μέγιστο μήκος που μπορεί να
% πετύχει είναι το μήκος του διαστήματος που διάλεξε συν το μέγιστο μήκος μεταξύ
% όλων των διαστημάτων που δεν επικαλύπτονται από εκείνο. Τα διαστήματα αυτά
% είναι τα
% 
% \[ \{ [s_{j}, f_{j}): j < i \land (f_{i} \leq s_{j} \lor f_{j} \leq s_{i})\} \]
% 
% Όμως λόγω της ταξινόμησης $j < i \implies f_{j} \leq f_{i}$. Και επειδή $s_{i}
% < f_{i}$ για κάθε $i$ ισχύει ότι $s_{j} \leq f_{i}$. Άρα τα διαστήματα
% που δεν επικαλύπτονται περιγράφονται από τη σχέση
% 
% \[ \{ [s_{j}, f_{j}): j \leq p(i) \} \]
% 
% Στην περίπτωση που δεν επιλέξει το $i$-οστό διάστημα τότε το μέγιστο μήκος που
% μπορεί να πετύχει είναι το μέγιστο μήκος μεταξύ όλων των υπόλοιπων διαστημάτων.
% 
% \subsubsection{Υπολογιστική πολυπλοκότητα}
% 
% Ο αλγόριθμος αρχικά ταξινομεί την είσοδό του, το οποιό γίνεται με πολυπλοκότητα
% $O(n\log{}n)$. Επιπλέον, επειδή έχουμε ταξινομήσει τα διαστήματα με βάση το
% $f_{i}$ η συνάρτηση $p(i)$ μπορεί να υπολογιστεί σε χρόνο $O(\log{}n)$ με
% binary search.
% 
% Η αναδρομική σχέση μπορεί να υπολογιστεί με δυναμικό προγραμματισμό. Το state
% space έχει μέγεθος $n$ και κάθε βήμα κάνει στη χειρότερη περίπτωση $O(\log{}n)$
% χρόνο λόγω του υπολογισμού της $p(i)$.
% 
% Άρα η συνολική πολυπλοκότητα είναι $O(n\log{}n)$.
% 
% \section{Άσκηση 5}
% 
% \subsection{Ένας υπάλληλος εξυπηρέτησης}
% 
% Ο αλγόριθμος θα εξυπηρετήσει τους πελάτες σε φθίνουσα σειρά του λόγου βάρους
% προς χρόνο εξυπηρέτησης $f_{i} = \frac{w_{i}}{p_{i}}$:
% 
% \[ f_{1} \geq f_{2} \geq \cdots \geq f_{n} \]
% 
% Θα χρησιμοποιήσουμε ένα επιχείρημα ανταλλαγής για να δείξουμε ότι αυτή η σειρά
% είναι η βέλτιστη. Έστω $s^{*}$ η βέλτιστη μετάθεση πελατών. Έστω ότι η μετάθεση
% $s^{*}$ είναι διαφορετική από την μετάθεση $s$ της άπληστης επιλογή. Εφόσον είναι
% διαφορετική τότε στην $s^{*}$ θα υπάρχει κάποιος πελάτης $i$ που προηγείται του
% πελάτη $j$ αλλά $f_{i} < f_{j}$. Επειδή αυτοί οι δύο πελάτες είναι ο ένας μετά
% τον άλλο η μεταξύ τους σειρά τους δεν επηρέαζει τον χρόνο εξυπηρέτησης των
% υπολοίπων πελατών. Στην αρχική τους διάταξη αν ο πελάτης $j$ έχει χρόνο
% εξυπηρέτησης $C_{j}$, τότε ο πελάτης $i$ εξυπηρετείται σε χρόνο $C_{j} -
% p_{j}$. Ανταλλάσοντας τη θέση των $i$ και $j$ δημιουργείται μία καινούρια
% διάταξη με μικρότερο κόστος από την αρχική.
% 
% \begin{equation} \label{eq1}
% \begin{split}
%   [w_{i}(C_{j} - p_{j}) + w_{j}C_{j}] - [w_{j}(C_{j} - p_{i}) + w_{i}C_{j}] & = w_{j}p_{i} - w_{i}p_{j} \\
%                                                                             & = p_{i}p_{j}\left(\frac{w_{j}}{p_{j}} - \frac{w_{i}}{p_{i}}\right) > 0
% \end{split}
% \end{equation}
% 
% Αυτό όμως είναι άτοπο άρα ο άπληστος αλγόριθμος είναι βέλτιστος.
% 
% 
% \subsection{Δύο υπάλληλοι εξυπηρέτησης}
% 
% TODO
% 
% \subsection{N υπάλληλοι εξυπηρέτησης}
% 
% TODO
% 
% 
% 
